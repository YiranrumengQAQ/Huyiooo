<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Spiral Cipher - çŸ©é˜µèºæ—‹åŠ å¯†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'Courier New', monospace;
            background: linear-gradient(45deg, #0f2027, #203a43, #2c5364);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5);
            padding: 45px;
            max-width: 900px;
            width: 100%;
            backdrop-filter: blur(10px);
        }
        
        .header {
            text-align: center;
            margin-bottom: 35px;
        }
        
        h1 {
            font-size: 36px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .subtitle {
            color: #666;
            font-size: 13px;
            letter-spacing: 1px;
        }
        
        .algorithm-badge {
            display: inline-block;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .input-section {
            margin-bottom: 25px;
        }
        
        label {
            display: block;
            color: #333;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 15px;
        }
        
        label::before {
            content: "â–¸ ";
            color: #667eea;
            font-weight: bold;
        }
        
        textarea, input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
            background: #fafafa;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 25px 0;
        }
        
        button {
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-encrypt {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .btn-decrypt {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .btn-clear {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .info-panel {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-left: 5px solid #667eea;
            padding: 20px;
            border-radius: 10px;
            margin-top: 25px;
        }
        
        .info-panel h3 {
            color: #667eea;
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        .info-panel ul {
            list-style: none;
            padding-left: 0;
        }
        
        .info-panel li {
            padding: 8px 0;
            color: #555;
            line-height: 1.6;
        }
        
        .info-panel li::before {
            content: "â—† ";
            color: #667eea;
            font-weight: bold;
            margin-right: 8px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” Matrix Spiral Cipher</h1>
            <p class="subtitle">çŸ©é˜µèºæ—‹åŠ å¯†ç³»ç»Ÿ - å®Œå…¨è‡ªç ”ç®—æ³•</p>
            <span class="algorithm-badge">åŸåˆ›ä¸‰ç»´çŸ©é˜µå˜æ¢åŠ å¯†</span>
        </div>
        
        <div class="input-section">
            <label>è¾“å…¥æ–‡æœ¬</label>
            <textarea id="inputText" placeholder="è¯·è¾“å…¥è¦åŠ å¯†æˆ–è§£å¯†çš„æ–‡æœ¬..."></textarea>
        </div>
        
        <div class="input-section">
            <label>åŠ å¯†å¯†é’¥</label>
            <input type="text" id="secretKey" placeholder="è¾“å…¥æ‚¨çš„å¯†é’¥" value="MyMatrix2025">
        </div>
        
        <div class="controls">
            <button class="btn-encrypt" onclick="performEncrypt()">ğŸ”’ åŠ å¯†</button>
            <button class="btn-decrypt" onclick="performDecrypt()">ğŸ”“ è§£å¯†</button>
            <button class="btn-clear" onclick="clearFields()">ğŸ—‘ï¸ æ¸…ç©º</button>
        </div>
        
        <div class="input-section">
            <label>è¾“å‡ºç»“æœ</label>
            <textarea id="outputText" placeholder="åŠ å¯†/è§£å¯†ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..." readonly></textarea>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="inputLen">0</div>
                <div class="stat-label">è¾“å…¥å­—ç¬¦æ•°</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="outputLen">0</div>
                <div class="stat-label">è¾“å‡ºå­—ç¬¦æ•°</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="complexity">-</div>
                <div class="stat-label">å¤æ‚åº¦æŒ‡æ•°</div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>ğŸ§® ç®—æ³•åŸç†è¯´æ˜</h3>
            <ul>
                <li><strong>èºæ—‹çŸ©é˜µå¡«å……</strong>ï¼šæ–‡æœ¬æŒ‰é¡ºæ—¶é’ˆèºæ—‹è·¯å¾„å¡«å…¥åŠ¨æ€çŸ©é˜µä¸­</li>
                <li><strong>ä¸‰ç»´åæ ‡å˜æ¢</strong>ï¼šæ¯ä¸ªå­—ç¬¦æ˜ å°„åˆ°(x,y,z)ä¸‰ç»´ç©ºé—´ï¼ŒåŸºäºå¯†é’¥è¿›è¡Œæ—‹è½¬å˜æ¢</li>
                <li><strong>åŠ¨æ€å­—ç¬¦è¡¨</strong>ï¼šå¯†é’¥ç”Ÿæˆå”¯ä¸€çš„å­—ç¬¦æ˜ å°„è¡¨ï¼Œæ¯æ¬¡åŠ å¯†éƒ½ä¸åŒ</li>
                <li><strong>æ³¢å‡½æ•°è°ƒåˆ¶</strong>ï¼šä½¿ç”¨æ­£å¼¦/ä½™å¼¦å‡½æ•°å¯¹å­—ç¬¦è¿›è¡Œéçº¿æ€§å˜æ¢</li>
                <li><strong>åˆ†å±‚ç¼–ç </strong>ï¼šçŸ©é˜µæŒ‰å±‚çº§è¿›è¡Œä¸åŒå¼ºåº¦çš„ç¼–ç å¤„ç†</li>
                <li><strong>æ ¡éªŒå’Œä¿æŠ¤</strong>ï¼šè‡ªåŠ¨æ·»åŠ æ ¡éªŒæœºåˆ¶ï¼Œé˜²æ­¢æ•°æ®ç¯¡æ”¹</li>
            </ul>
        </div>
    </div>
    
    <script>
        // ==================== Matrix Spiral Cipher æ ¸å¿ƒç®—æ³• ====================
        
        class MatrixSpiralCipher {
            constructor(key) {
                this.key = key || 'DefaultMatrixKey';
                this.keyHash = this.hashKey(this.key);
            }
            
            // å¯†é’¥å“ˆå¸Œå‡½æ•°ï¼ˆç”Ÿæˆå”¯ä¸€æ•°å€¼ï¼‰
            hashKey(key) {
                let hash = 0;
                for (let i = 0; i < key.length; i++) {
                    const char = key.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
                }
                return Math.abs(hash);
            }
            
            // è®¡ç®—æœ€ä½³çŸ©é˜µå°ºå¯¸
            getMatrixSize(length) {
                const size = Math.ceil(Math.sqrt(length));
                return size;
            }
            
            // ç”Ÿæˆèºæ—‹åæ ‡åºåˆ—
            generateSpiralPath(size) {
                const path = [];
                let top = 0, bottom = size - 1;
                let left = 0, right = size - 1;
                
                while (top <= bottom && left <= right) {
                    // å‘å³
                    for (let i = left; i <= right; i++) {
                        path.push([top, i]);
                    }
                    top++;
                    
                    // å‘ä¸‹
                    for (let i = top; i <= bottom; i++) {
                        path.push([i, right]);
                    }
                    right--;
                    
                    // å‘å·¦
                    if (top <= bottom) {
                        for (let i = right; i >= left; i--) {
                            path.push([bottom, i]);
                        }
                        bottom--;
                    }
                    
                    // å‘ä¸Š
                    if (left <= right) {
                        for (let i = bottom; i >= top; i--) {
                            path.push([i, left]);
                        }
                        left++;
                    }
                }
                
                return path;
            }
            
            // ä¸‰ç»´åæ ‡å˜æ¢
            transform3D(char, x, y, keyIndex) {
                const code = char.charCodeAt(0);
                const keyByte = this.key.charCodeAt(keyIndex % this.key.length);
                
                // ä¸‰ç»´æ—‹è½¬å˜æ¢
                const theta = (keyByte / 255) * Math.PI * 2;
                const phi = (x / 10) * Math.PI;
                
                // çƒåæ ‡å˜æ¢
                const r = code;
                const newX = r * Math.sin(phi) * Math.cos(theta);
                const newY = r * Math.sin(phi) * Math.sin(theta);
                const newZ = r * Math.cos(phi);
                
                // ç»„åˆå˜æ¢ç»“æœ
                const transformed = Math.floor((newX + newY + newZ) / 3) ^ keyByte ^ (x * y);
                
                return transformed & 0xFF;
            }
            
            // æ³¢å‡½æ•°è°ƒåˆ¶
            waveModulation(value, position) {
                const freq = (this.keyHash % 7) + 3;
                const wave = Math.sin(position / freq) * 127 + 128;
                return (value + Math.floor(wave)) & 0xFF;
            }
            
            // åŠ¨æ€å­—ç¬¦æ˜ å°„
            dynamicCharMap(byte, index) {
                const seed = (this.keyHash + index) % 256;
                const mapped = ((byte * 37) + seed) ^ (index % 256);
                return mapped & 0xFF;
            }
            
            // åŠ å¯†å‡½æ•°
            encrypt(plaintext) {
                if (!plaintext) return '';
                
                const size = this.getMatrixSize(plaintext.length);
                const spiral = this.generateSpiralPath(size);
                
                // æ­¥éª¤1ï¼šå°†æ–‡æœ¬æŒ‰èºæ—‹è·¯å¾„å¡«å…¥çŸ©é˜µ
                const matrix = Array(size).fill(null).map(() => Array(size).fill(''));
                for (let i = 0; i < plaintext.length; i++) {
                    const [x, y] = spiral[i];
                    matrix[x][y] = plaintext[i];
                }
                
                // æ­¥éª¤2ï¼šä¸‰ç»´å˜æ¢ + æ³¢å‡½æ•°è°ƒåˆ¶ + åŠ¨æ€æ˜ å°„
                const encrypted = [];
                let index = 0;
                
                for (let i = 0; i < spiral.length; i++) {
                    const [x, y] = spiral[i];
                    const char = matrix[x][y];
                    
                    if (char) {
                        // ä¸‰å±‚å˜æ¢
                        let byte = this.transform3D(char, x, y, index);
                        byte = this.waveModulation(byte, index);
                        byte = this.dynamicCharMap(byte, index);
                        
                        encrypted.push(byte);
                        index++;
                    }
                }
                
                // æ­¥éª¤3ï¼šæ·»åŠ å…ƒæ•°æ®ï¼ˆçŸ©é˜µå¤§å° + æ ¡éªŒå’Œï¼‰
                const checksum = this.calculateChecksum(encrypted);
                const metadata = [size, checksum];
                
                // æ­¥éª¤4ï¼šè½¬æ¢ä¸ºè‡ªå®šä¹‰Baseç¼–ç 
                return this.toCustomBase(metadata.concat(encrypted));
            }
            
            // è§£å¯†å‡½æ•°
            decrypt(ciphertext) {
                if (!ciphertext) return '';
                
                try {
                    // æ­¥éª¤1ï¼šè§£ç 
                    const bytes = this.fromCustomBase(ciphertext);
                    
                    // æ­¥éª¤2ï¼šæå–å…ƒæ•°æ®
                    const size = bytes[0];
                    const checksum = bytes[1];
                    const encrypted = bytes.slice(2);
                    
                    // æ­¥éª¤3ï¼šæ ¡éªŒå®Œæ•´æ€§
                    if (this.calculateChecksum(encrypted) !== checksum) {
                        throw new Error('æ•°æ®æ ¡éªŒå¤±è´¥');
                    }
                    
                    // æ­¥éª¤4ï¼šç”Ÿæˆèºæ—‹è·¯å¾„
                    const spiral = this.generateSpiralPath(size);
                    
                    // æ­¥éª¤5ï¼šé€†å‘å˜æ¢
                    const decrypted = [];
                    
                    for (let i = 0; i < encrypted.length; i++) {
                        const [x, y] = spiral[i];
                        
                        // é€†å‘ä¸‰å±‚å˜æ¢
                        let byte = this.invDynamicCharMap(encrypted[i], i);
                        byte = this.invWaveModulation(byte, i);
                        byte = this.invTransform3D(byte, x, y, i);
                        
                        decrypted.push(String.fromCharCode(byte));
                    }
                    
                    return decrypted.join('');
                    
                } catch (e) {
                    throw new Error('è§£å¯†å¤±è´¥ï¼š' + e.message);
                }
            }
            
            // é€†å‘åŠ¨æ€å­—ç¬¦æ˜ å°„
            invDynamicCharMap(byte, index) {
                const seed = (this.keyHash + index) % 256;
                // æ±‚é€†ï¼šbyte = ((original * 37) + seed) ^ (index % 256)
                byte = byte ^ (index % 256);
                byte = (byte - seed + 256) & 0xFF;
                // 37çš„æ¨¡256ä¹˜æ³•é€†å…ƒæ˜¯ 141
                byte = (byte * 141) & 0xFF;
                return byte;
            }
            
            // é€†å‘æ³¢å‡½æ•°è°ƒåˆ¶
            invWaveModulation(value, position) {
                const freq = (this.keyHash % 7) + 3;
                const wave = Math.sin(position / freq) * 127 + 128;
                return (value - Math.floor(wave) + 256) & 0xFF;
            }
            
            // é€†å‘ä¸‰ç»´å˜æ¢
            invTransform3D(transformed, x, y, keyIndex) {
                const keyByte = this.key.charCodeAt(keyIndex % this.key.length);
                
                // é€†å‘XOR
                let value = transformed ^ keyByte ^ (x * y);
                
                // åå‘çƒåæ ‡ï¼ˆè¿‘ä¼¼é€†å˜æ¢ï¼‰
                const theta = (keyByte / 255) * Math.PI * 2;
                const phi = (x / 10) * Math.PI;
                
                const cosFactor = Math.cos(theta) * Math.sin(phi);
                const sinFactor = Math.sin(theta) * Math.sin(phi);
                const zFactor = Math.cos(phi);
                
                const divisor = (cosFactor + sinFactor + zFactor) / 3;
                const original = divisor !== 0 ? Math.floor(value / divisor) : value;
                
                return original & 0xFF;
            }
            
            // è®¡ç®—æ ¡éªŒå’Œ
            calculateChecksum(bytes) {
                let sum = 0;
                for (let i = 0; i < bytes.length; i++) {
                    sum = (sum + bytes[i] * (i + 1)) & 0xFF;
                }
                return sum;
            }
            
            // è‡ªå®šä¹‰Baseç¼–ç ï¼ˆæ‰©å±•å­—ç¬¦é›†ï¼‰
            toCustomBase(bytes) {
                const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=!@#$%^&*()[]{}';
                let result = '';
                
                for (let i = 0; i < bytes.length; i++) {
                    const byte = bytes[i];
                    result += charset[byte % charset.length];
                    result += charset[Math.floor(byte / charset.length)];
                }
                
                return result;
            }
            
            // è‡ªå®šä¹‰Baseè§£ç 
            fromCustomBase(encoded) {
                const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=!@#$%^&*()[]{}';
                const bytes = [];
                
                for (let i = 0; i < encoded.length; i += 2) {
                    const low = charset.indexOf(encoded[i]);
                    const high = charset.indexOf(encoded[i + 1]);
                    
                    if (low === -1 || high === -1) {
                        throw new Error('æ— æ•ˆçš„ç¼–ç æ ¼å¼');
                    }
                    
                    const byte = (high * charset.length + low) & 0xFF;
                    bytes.push(byte);
                }
                
                return bytes;
            }
        }
        
        // ==================== UI äº¤äº’å‡½æ•° ====================
        
        function performEncrypt() {
            const input = document.getElementById('inputText').value;
            const key = document.getElementById('secretKey').value;
            
            if (!input.trim()) {
                alert('âš ï¸ è¯·è¾“å…¥è¦åŠ å¯†çš„æ–‡æœ¬ï¼');
                return;
            }
            
            if (!key.trim()) {
                alert('âš ï¸ è¯·è¾“å…¥åŠ å¯†å¯†é’¥ï¼');
                return;
            }
            
            try {
                const cipher = new MatrixSpiralCipher(key);
                const encrypted = cipher.encrypt(input);
                
                document.getElementById('outputText').value = encrypted;
                updateStats(input.length, encrypted.length, 'HIGH');
                
            } catch (e) {
                alert('âŒ åŠ å¯†å¤±è´¥ï¼š' + e.message);
            }
        }
        
        function performDecrypt() {
            const input = document.getElementById('inputText').value;
            const key = document.getElementById('secretKey').value;
            
            if (!input.trim()) {
                alert('âš ï¸ è¯·è¾“å…¥è¦è§£å¯†çš„å¯†æ–‡ï¼');
                return;
            }
            
            if (!key.trim()) {
                alert('âš ï¸ è¯·è¾“å…¥è§£å¯†å¯†é’¥ï¼');
                return;
            }
            
            try {
                const cipher = new MatrixSpiralCipher(key);
                const decrypted = cipher.decrypt(input);
                
                document.getElementById('outputText').value = decrypted;
                updateStats(input.length, decrypted.length, 'OK');
                
            } catch (e) {
                alert('âŒ è§£å¯†å¤±è´¥ï¼šå¯†é’¥é”™è¯¯æˆ–å¯†æ–‡æŸåï¼');
            }
        }
        
        function clearFields() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            updateStats(0, 0, '-');
        }
        
        function updateStats(inputLen, outputLen, complexity) {
            document.getElementById('inputLen').textContent = inputLen;
            document.getElementById('outputLen').textContent = outputLen;
            document.getElementById('complexity').textContent = complexity;
        }
        
        // å®æ—¶ç»Ÿè®¡è¾“å…¥é•¿åº¦
        document.getElementById('inputText').addEventListener('input', function() {
            updateStats(this.value.length, document.getElementById('outputText').value.length, '-');
        });
    </script>
</body>
</html>
